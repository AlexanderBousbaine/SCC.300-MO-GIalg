
component provides App requires io.Output out, PopulationInitialiser popInit, data.DecUtil du, data.IntUtil iu, os.Run run, time.Timer time, io.FileSystem fs, time.Calendar cal, util.Random rand, io.File, net.Stream stm, lang.Thread {
	
	int populationSize = 12
	int moGenerations = 10
	dec mutationChance = 0.8
	dec crossoverChance = 0.2
	int elites = 2

	//must be a multiple of 3 for simplicity
	int numRuns = 9
	
	char confirmPath[] = "./CompletionConfirmation"
	char GIalgorithmPath[] = "/home/abousbaine/GIalgorithm"
	
	//holds the parameters to be passed to the GIAlgorithm
	char paramString[] = ""
	
	//run a configuration 12 times by running the following sequentially - Egg Layer 2
	char runCommand1[] = ""
	char runCommand2[] = ""
	char runCommand3[] = ""
	
	//kills all windows but the 0th window in which the control script runs
	char killCommand[] = "tmux kill-window -a -t 0"
	
	int App:main(AppParam params[])
	{

		//create configurations
		GiaConfig configs[] = popInit.generateInitialPopConfigs(populationSize)
		dec configFitness[] = new dec[populationSize]
		
		//pass configurations into various instances of GIalgorithm
		// - make GIalg write to some disk space when it's done or something
		// - check every 10mins? for that thing 
		FileEntry compDir[]
		
		if(!resetGIalgOutput()) { return 0 }
		
		out.println("compiling GIalgorithm codebase")
		compilePopBase()
		
		//THE GAME LOOP - SEE LATER
		//Egg Layer 4
		//For every generation of the meta-optimiser
		for(int moGen = 0; moGen < moGenerations; moGen++) {
			out.println("----------------------------------------------------------------")
			out.println("STARTING GENERATION: $moGen")
			out.println("----------------------------------------------------------------")
		
			//Egg Layer 3
			//For every population member of each generation - execute 
			for(int pops = 0; pops < populationSize; pops++) {
			
				//empty confirmation folder
				run.execute("rm -r $confirmPath")
				if(!fs.createDirectory("$confirmPath")) {
					out.println("failed to reset cc folder")
					return 0
				}	
			
				//empty result folder from GIalgorithm
				if(!resetGIalgOutput()) { return 0 }

				out.println("Pop number: $(pops+1) / $populationSize")
				
				/*
				out.println("Writing pre-config")
				char fName[] = "gen $moGen preConfig $(pops+1)"
				File configFile = new File("./Configurations/$fName.csv", File.WRITE)
				configFile.write("$(popInit.stringifyCommad(configs[pops]))\n")
				configFile.close()
				*/

				//Egg Layer 2
				//Execute each configuration 12 times
				
				//set current members parameters to be passed in with runCommands
				paramString = popInit.stringify(configs[pops])
				out.println("Param String: $paramString")
				
				updateRunCommands()
				
				//out.println("Running: $runCommand1")
				
				//NEW METHOD
				if(numRuns%3 != 0) {
					out.println("setting num runs to 9")
					numRuns = 9
				}
				
				out.println("Starting GIalgorithm execution")
				
				Thread executions[] = new Thread[3]
				
				//run 3 threads at a time
				for(int r = 1; r <= numRuns; r+=3) {
					out.println("Running threads:")
					out.println("MainModular $(r)")
					out.println("MainModular $(r+1)")
					out.println("MainModular $(r+2)")
					executions[0] = asynch::runCommand("cd $GIalgorithmPath && dana MainModular $(r) MOGI $paramString >logfileMO$(r).txt 2>errorfileMO1$(r).txt")
					executions[1] = asynch::runCommand("cd $GIalgorithmPath && dana MainModular $(r+1) MOGI $paramString >logfileMO$(r+1).txt 2>errorfileMO1$(r+1).txt")
					executions[2] = asynch::runCommand("cd $GIalgorithmPath && dana MainModular $(r+2) MOGI $paramString >logfileMO$(r+2).txt 2>errorfileMO1$(r+2).txt")
				
					out.println("Joining threads")
					executions[0].join()
					executions[1].join()
					executions[2].join()
				}
				
				out.println("GIalgorithm execution finished")
				
				//OLD METHOD
				/*
				//run first 4
				run.execute(runCommand1)
				//wait for half an hour then begin checking for completion
				//if(!checkBatchAfter(4, 1200000)) {
				if(!checkBatchAfter(4, 1800000)) {
					out.println("Could not confirm completion of runCommand1.\nExiting Program.")
					//kill all running processes and move on - don't just kill the program
					run.execute(killCommand)
				}
				out.println("finished p1")
				
				//when first 4 have been completed, run next 4
				//create subFolder of CompletionConfirmation
				run.execute(runCommand2)
				//wait for half an hour then begin checking for completion
				if(!checkBatchAfter(8, 1800000)) {
					out.println("Could not confirm completion of runCommand2.\nExiting Program.")
					//kill all running processes and move on - don't just kill the program
					run.execute(killCommand)
				}
				out.println("finished p2")
				
				//when next 4 have been completed, run last 4
//				run.execute(runCommand3)
				//wait for half an hour then begin checking for completion
//				if(!checkBatchAfter(12, 1800000)) {
//					out.println("Could not confirm completion of runCommand3.\nExiting Program.")
					//kill all running processes and move on - don't just kill the program
//					run.execute(killCommand)
//				}
				*/

				out.println("\nPop $(pops+1) of $populationSize in Generation $(moGen+1) Complete")
				
				out.println("Executing analysis script.")
				//call evaluation script
				run.execute("python3 $GIalgorithmPath/csv_script.py")
				run.execute("python3 Fitness_Extraction.py $GIalgorithmPath/output_files/MOGI")
				
				dec fitness
				//read in fitness
				if(fs.exists("./fitness.txt")){
					File file = new File("./fitness.txt", File.READ)
					byte fit[] = file.read(file.getSize())
					fitness = du.decFromString(fit)
					file.close()
					
					fs.delete("./fitness.txt")
				}
				else {
					out.println("Could not find resultant fitness, assuming dud")
					fitness = 10.0
				}
				
				out.println("Setting fitness")
				configFitness[pops] = fitness
				out.println("pop cycle ended")
			}
			
			//write configs to file
			//include fitness values
			writeConfigsToFile(configs, configFitness, moGen)
			out.println("config and fitness written")
			
			out.println("Mutation and Crossover")
			dec cfCopy[] = clone configFitness
			GiaConfig newConfigs[] = new GiaConfig[populationSize]
			//create new population for next generation
			//-> Outsource to PopulationInitialiser
			for(int i = 0; i < populationSize; i++) {
				if(i < elites) {
					int idx = 0
					dec fittest = 1.0
					for(int f = 0; f < cfCopy.arrayLength; f++) {
						if(cfCopy[f] < fittest) {
							fittest = cfCopy[f]
							idx = f
						}
					}
					
					newConfigs[i] = configs[idx]
					cfCopy[idx] = 1.0
					out.println("Elite set!")
					
					/*
					File eFile = new File("./elites/elite$(i)_Gen$(moGen).txt", File.CREATE)
					eFile.write(popInit.stringifyCommad(newConfigs[i]))
					eFile.close()
					*/
				}
				else {
					DateTime dt = cal.getTime()
					rand.setSeed(dt.minute + dt.second + dt.millisecond)
					rand.getDec(0, 1)		
					
					//select parents - Roulette Wheel
					//calculate cumulative fitness
					dec cumulativeFitness[] = new dec[configFitness.arrayLength]
					dec cumFit = 0
					for(int a = 0; a < configFitness.arrayLength; a++) {
						cumFit += configFitness[a]
						cumulativeFitness[i] = cumFit
					}
					
					//Select parent configs
					GiaConfig p1
					GiaConfig p2
					for(int p = 0; p < 2; p++) {
						dec val = rand.getDec(0, cumFit)
						int idx = 0
						for(int j = 0; j < configFitness.arrayLength; j++) {
							if(val < cumulativeFitness[j]) {
								idx = j
								//set so that the index cannot be chosen again -> can't breed with oneself
								cumulativeFitness[j] = -1.0
								break
							}
						}
						if(p == 0) {
							p1 = clone configs[idx]
						}
						if(p == 1) {
							p2 = clone configs[idx]
						}
					}
		
					//do crossover - uniform crossover
					bool crossed
					//go through all genes
					for(int v = 0; v < 18; v++) {
						crossed = false
						//if chance achieved, perform crossover
						if(rand.getDec(0, 1) < crossoverChance) {
							if(v < 2 && !crossed) {
								//clone to prevent read-only errors
								dec temp1 = clone p1:.v
								dec temp2 = clone p2:.v
								p1:.v = temp2
								p2:.v = temp1
								crossed = true
							}
							if(v < 4 && !crossed) {
								int temp1 = clone p1:.v
								int temp2 = clone p2:.v
								p1:.v = temp2
								p2:.v = temp1
								crossed = true
							}
							if(v < 8 & & !crossed) {
								dec tempArr1[] = clone p1.mutWeights
								dec tempVal1 = tempArr1[v-4]
								
								dec tempArr2[] = clone p2.mutWeights
								dec tempVal2 = tempArr2[v-4]
								
								tempArr1[v-4] = tempVal2
								tempArr2[v-4] = tempVal1
								
								p1.mutWeights = tempArr1
								p2.mutWeights = tempArr2
								crossed = true
							}
							if(!crossed) {
								dec tempArr1[] = clone p1.opWeights
								dec tempVal1 = tempArr1[v-8]
								
								dec tempArr2[] = clone p2.opWeights
								dec tempVal2 = tempArr2[v-8]
								
								tempArr1[v-8] = tempVal2
								tempArr2[v-8] = tempVal1
								
								p1.opWeights = tempArr1
								p2.opWeights = tempArr2
								crossed = true
							}
						}
					}
					
					p1 = mutate(p1)
					p2 = mutate(p2)
					
					//add into new generation
					newConfigs[i] = p1
					//if not at the end of the list
					if(i+1 < populationSize) {
						//add another population member
						newConfigs[i+1] = p2
						i++
					}
				}
			}
			configs = newConfigs
		}
		//*/
		
		return 0
	}
	
	void runCommand(char cmd[]) {
		run.execute(cmd)
	}
	
	GiaConfig mutate(GiaConfig c) {
		GiaConfig conf = clone c
		if(rand.getDec(0, 1) < mutationChance) {
			//do mutation - simply select random variable and generate random valid value
			int varNum = rand.getInt(18)
			bool mutated = false
			
			out.println("mutating $varNum")
						
			//0 to 15 inclusive
			int validInt1 = rand.getInt(ConfigDomains.ELITES_UPPER+1)
			//1 to 15 inclusive
			int validInt2 = rand.getInt(ConfigDomains.MUTLIM_UPPER)+1
			//0.01 to 1
			dec validDec1 = popInit.roundTo2DP(rand.getDec(ConfigDomains.MUTPERC_LOWER, ConfigDomains.MUTPERC_UPPER))
			//0 to 1
			dec validDec2 = popInit.roundTo2DP(rand.getDec(ConfigDomains.MUTWEIGHT_LOWER, ConfigDomains.MUTWEIGHT_UPPER))
					
			if(varNum < 2 && !mutated) {
				conf:.varNum = validDec1
				mutated = true
			}
			if(varNum == 2 && !mutated) {
				conf.numElites = validInt1
				mutated = true
			}
			if(varNum == 3 && !mutated) {
				conf.mutationLimit = validInt2
				mutated = true
			}
			if(varNum < 8 && !mutated) {
				dec tempArr1[] = clone conf.mutWeights							
				tempArr1[varNum-4] = validDec2
				conf.mutWeights = tempArr1
				mutated = true
			}
			if(!mutated) {
				dec tempArr1[] = clone conf.opWeights
				tempArr1[varNum-8] = validDec2
				conf.opWeights = tempArr1
				mutated = true
			}
		}
		
		return conf
	}
	
	bool resetGIalgOutput() {
		bool deleted = true
		FileEntry entries[] = fs.getDirectoryContents("$GIalgorithmPath/output_files/MOGI")
		for(int a = 0; a < entries.arrayLength; a++) {
			//out.println("To delete: $GIalgorithmPath/output_files/MOGI/$(entries[a].name)")
			//use bash command as FileSystem wasn't cutting it - couldn't recursively delete contents of folders
			RunStatus r = run.execute("rm -r $GIalgorithmPath/output_files/MOGI/$(entries[a].name)")
			deleted = r.executed
			if(!deleted) {
				out.println("Failed to delete current contents of GIalg's output folders")
				return false
			}
		}
		if(deleted){
			out.println("GIalgorithm output folder deleted")
			
			bool created = true
			for(int f = 1; f <= numRuns; f++) {
				if(!fs.createDirectory("$GIalgorithmPath/output_files/MOGI/$f")) {
				out.println("Didn't create folder $f")
					created = false
				}
			}
			if(!created) {
				out.println("failed to recreate GIAlgorithm output folder")
				return false
			}
		}
		else {
			out.println("failed to reset GIalg's output folder")
			return false
		}
		
		out.println("GIalg output folders successfully prepared")
		return true
	}
	
	void compilePopBase() {
		run.execute("cd $GIalgorithmPath && dnc .")
	}
	
	void updateRunCommands() {
		//change so that don't issue tmux commands and so it blocks
		runCommand1 = "tmux new-window 'cd $GIalgorithmPath && dana MainModular 1 MOGI $paramString >logfileMO1.txt 2>errorfileMO1.txt' \\; new-window 'cd $GIalgorithmPath && dana MainModular 2 MOGI $paramString >logfileMO2.txt 2>errorfileMO2.txt' \\; new-window 'cd $GIalgorithmPath && dana MainModular 3 MOGI $paramString >logfileMO3.txt 2>errorfileMO3.txt' \\; new-window 'cd $GIalgorithmPath && dana MainModular 4 MOGI $paramString >logfileMO4.txt 2>errorfileMO4.txt' \\; detach-client"
		runCommand2 = "tmux new-window 'cd $GIalgorithmPath && dana MainModular 5 MOGI $paramString >logfileMO5.txt 2>errorfileMO5.txt' \\; new-window 'cd $GIalgorithmPath && dana MainModular 6 MOGI $paramString >logfileMO6.txt 2>errorfileMO6.txt' \\; new-window 'cd $GIalgorithmPath && dana MainModular 7 MOGI $paramString >logfileMO7.txt 2>errorfileMO7.txt' \\; new-window 'cd $GIalgorithmPath && dana MainModular 8 MOGI $paramString >logfileMO8.txt 2>errorfileMO8.txt' \\; detach-client"
		runCommand3 = "tmux new-window 'cd $GIalgorithmPath && dana MainModular 9 MOGI $paramString' \\; new-window 'cd $GIalgorithmPath && dana MainModular 10 MOGI $paramString' \\; new-window 'cd $GIalgorithmPath && dana MainModular 11 MOGI $paramString' \\; new-window 'cd $GIalgorithmPath && dana MainModular 12 MOGI $paramString' \\; detach-client"
	}
	
	void writeConfigsToFile(GiaConfig configs[], dec fitness[], int genNum) {
		DateTime dt = cal.getTime()
		int yr = dt.year
		int mn = dt.month
		int day = dt.day
		int milsec = dt.millisecond
		int sec = dt.second
		int min = dt.minute
		int hr = dt.hour
		char fName[] = "gen $genNum $hr$min$sec$milsec - $yr $mn $day"
		
		File configFile = new File("./Configurations/$fName.csv", File.WRITE)
		
		for(int i = 0; i < configs.arrayLength; i++) {
			configFile.write("$(popInit.stringifyCommad(configs[i])), $(fitness[i])\n")
			// configFile.write(popInit.stringifyCommad(configs[i]))
		}
		
		configFile.close()
	}
	
	//return true if completion was found, otherwise false
	//will wait at least an hour + input time (millisec)
	//with an input of 20mins (1200000) entire wait time will be 1.5 hrs
	bool checkBatchAfter(int complThresh, int waitTime) {
		int fivesWaited = 0
		while(true) {
			time.sleep(waitTime)
			
			if(fivesWaited >= 6) {
				out.println("Checked an (half) hour's worth of five minute increments.\nGiving up and moving on.")
				return false
			}
			
			FileEntry contents[] = fs.getDirectoryContents("$confirmPath")
			out.println("Files Found: $(contents.arrayLength) of $complThresh")
			
			if(contents.arrayLength >= complThresh){
				out.println("Batch Finished")
				return true
			}
			else {
				out.println("Batch not finished after $(waitTime / 60000) mins")
				waitTime = waitTime/2
				
				if(waitTime <= 300000){ //if wait time is less than 5 mins
					waitTime = 300000
					fivesWaited++
				}
			}	
		}
		out.println("The wait and check function 'checkBatchAfter' has gotten out of it's forever loop in an unexpected fashion.")
		return false
	}
}
