
component provides PopulationInitialiser requires util.Random rand, io.Output out, data.DecUtil du, data.IntUtil iu, util.Math math{
	
	/*
		APPROACH 1:
		Randomly choose values from the domains for each variable
		Assess the uniqueness of the chosen variables and if they are at least n (50%?) unique, then allow them to become a population member
		Allow pass value to decrease as the number of successful configurations increase
		
		APPROACH 2:
		Create local copies of all the domains.
		Randomly select values from the domains for each variable.
		Remove selected value from the value pool once chosen.
		Repeat.
	
	*/
	
	GiaConfig[] PopulationInitialiser:generateInitialPopConfigs() {
		rand.setSeed(1)
		int numGoodConfigs = 0
		int totalConfigs = 0
		//maximum score is 18*num_configs, pass score is 9-num_configs?
		int passValue = 9
		int evalVal = 0
		GiaConfig configs[] = new GiaConfig[10]()
		
		while(numGoodConfigs < 10) {
			//out.print("MP: ")
			dec mutPerc = rand.getDec(ConfigDomains.MUTPERC_LOWER, ConfigDomains.MUTPERC_UPPER)
			//out.println("$mutPerc")
			
			dec hgtPerc = rand.getDec(ConfigDomains.HGTPERC_LOWER, ConfigDomains.HGTPERC_UPPER)
			//0 to 15
			int elites = rand.getInt(ConfigDomains.ELITES_UPPER+1)
			//1 to 15
			int mutLim = rand.getInt(ConfigDomains.MUTLIM_UPPER)+1
			
			int a
			dec mutWeights[] = new dec[4]
			for(a = 0; a < 4; a++) {
				mutWeights[a] = rand.getDec(ConfigDomains.MUTWEIGHT_LOWER, ConfigDomains.MUTWEIGHT_UPPER)
			}

			dec opWeights[] = new dec[10]
			for(a = 0; a < 10; a++) {
				opWeights[a] = rand.getDec(ConfigDomains.OPWEIGHT_LOWER, ConfigDomains.OPWEIGHT_UPPER)
			}
			
			GiaConfig c = new GiaConfig(mutPerc, hgtPerc, elites, mutLim, mutWeights, opWeights)
			
			evalVal = evaluateConfig(c, configs, numGoodConfigs)
			out.println("Config Evaluation Value: $evalVal")
			
			//pass value should decrease with every successful 
			if(evalVal < passValue){
				out.println("Config Passes")
				configs[numGoodConfigs] = c
				numGoodConfigs++
				passValue -= numGoodConfigs
			}
			else{
				out.println("Config Fails")
			}
			
			totalConfigs++
			out.println("Config attempt $totalConfigs")
		}
		
		return configs
	}
	
	int PopulationInitialiser:evaluateConfig(GiaConfig config, GiaConfig allConfigs[], int numConfigs) {
		int score = 0
		
		//if there is more than 1 config already created
		if(numConfigs > 1) {
		
			//iterate through all current configs
			for(int i = 0; i < numConfigs; i++) {
				
				GiaConfig compareFig = allConfigs[i]
				
				//iterate through all singular fields of the GiaConfig object
				for(int f = 0; f < 4; f++) {
				
					//if value of field in question matches
					if(config:.f == compareFig:.f) {
						score++
					}
				}
				
				int a
				//iterate through mutWeights
				for(a = 0; a < 4; a++){
					if(config:.4[a] == compareFig:.4[a]) {
						score++
					}
				}

				//iterate through opWeights
				for(a = 0; a < 10; a++){
					if(config:.5[a] == compareFig:.5[a]) {
						score++
					}
				}				
			}
		}
		
		return score
	}
	
	//void PopulationInitialiser:printConfig(GiaConfig c) {
	/*
		out.println("mutPercentage: $c.mutationPercentage")
		out.println("hgtPercentage: $c.hgtPercentage")
		out.println("elites: $c.numElites")
		out.println("mutationLimit: $c.mutationLimit")
		out.println("mutation Weights: $c.mutWeights")
		out.println("operation Weights: $c.opWeights")
	}
	//*/
	
	/*
	dec PopulationInitialiser:roundTo2DP(dec d){
		return (math.round(d*100)/100)
	}
	*/
}